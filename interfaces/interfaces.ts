/** * Created by ID on 16/2/17. */function printLabel(labelledObj:{label:string}) {    console.log(labelledObj.label);};var myObj = {size: 12, label: 'size 12 object'};printLabel(myObj);//size 12 objectinterface LabelledValue {    label:string;};function printLed(labelledObj:LabelledValue) {    console.log(labelledObj.label);};var my = {size: 10, label: 'size 10 object'};printLed(my);//size 10 object//可选属性interface SquareConfig {    color?:string;    width?:number};//定义返回值的类型必须包含某些字段，定义参数必须符合某些属性function caeateSquare(config:SquareConfig):{color:string;area:number} {    var newSquare = {color: 'white', area: 100};    if (config.color) {        newSquare.color = config.color;    }    if (config.width) {        newSquare.area = config.width;    }    return newSquare;};var mySquare = caeateSquare({color: 'black'});console.log(mySquare);//Object {color: "black", area: 100}/** *接口定义方法 *///接口中定义方法interface SearchFunc {    (source:string, substring:string):boolean;}//实现接口的方法（一）var mySearch:SearchFunc;mySearch = function (source:string, substring:string) {    var result = source.search(substring);    if (result == -1) {        return false;    } else {        return true;    }};//实现接口的方法（二）var mySearch1:SearchFunc;//参数名称无所谓，只有类型对就可以了。mySearch1 = function (src:string, sub:string) {    var result = src.search(sub);    if (result == -1) {        return false;    } else {        return true;    }};/** * 接口定义数组 * 我们也可以用接口来描述数组类型， * 它的声明方式与函数类型相似。数组类型会有一个'index'类型， * 我们用它来表示数组索引 * （数组下标）的类型。这样我们也需要索引所对应的返回值的类型。 *///表示 数组通过索引取得的值必须是  string类型。interface StringArray {    [index:number]:string}//虽然索引标识是描述数组和字典类型的数据的好方法，// 它同时也会强迫其他所有属性都与索引的返回类型相同。// 在下面的例子中，'length'属性的类型不符合索引的返回类型，这会导致类型检查抛出错误：interface Dictionary {    [index: string]: number;    length: number;    //name:string;//Error:(101, 5) TS2411: Property 'name' of type 'string' is not assignable to string index type 'number'.}var myStringArray:StringArray;myStringArray = ['bob', 'fred'];/** * 类实现接口 *///1，方法和属性interface  ClockInterface {    currentTime:Date;    setTime(d:Date);}class Clock implements ClockInterface {    currentTime:Date;    setTime(d:Date) {        this.currentTime = d;    }    constructor(h:number, m:number) {    }}//2，构造方法//---------------------------------------interface  ClockInterface1 {    new (hour:number, minute:number)}//这是因为当一个类实现一个接口时，//只有实例的部分会被进行检查。构造函数属于静态的部分，//它并不在检查的范围之内。所以下面会报错//Error:(137, 7) TS2420: Class 'Clockd' incorrectly implements interface 'ClockInterface1'.//class Clockd implements ClockInterface1 {//    constructor(h:number, m:number) {////    }//}class Clock2 {    constructor(h:number, m:number) {    }}var cs:ClockInterface1 = Clock2;var newClock = new cs(2, 30);//---------------------------------------/** * 用接口限制构造函数的签名 */interface  ClockConstructor {    new (hour:number, minute:number):ClockInterface2}interface ClockInterface2 {    tick()}function createClock(ctor:ClockConstructor, hour:number, minute:number):ClockInterface2 {    return new ctor(hour, minute);}class DigitalClock implements ClockInterface2 {    constructor(h:number, m:number) {    }    tick() {        console.log("beep beep");    }}class AnalogClock implements ClockInterface2 {    constructor(h:number, m:number) {    }    tick() {        console.log("tick tock");    }}var digital = createClock(DigitalClock, 12, 17);var analog = createClock(AnalogClock, 7, 32);/** * *//** * 接口继承 */interface Shape {    color:string;}interface  PenStroke {    penWidth:number;}interface Square extends PenStroke,Shape {    sideLength:number;}var square = <Square>{};square.color = 'blue';square.sideLength = 10;square.penWidth = 5.0;/** * 接口混合类型 */interface  Counter {    (start:number):string;    interval:number;    reset():void;}function getCounter():Counter {    var counter = <Counter>function (start:number) {    }    counter.interval = 123;    counter.reset = function () {        console.log(counter.interval)    }    return counter;}var c:Counter = getCounter();c(10);c.reset();c.interval = 5.0;/** * 接口继承类 * 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 * 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 * 接口同样会继承到类的private和protected成员。 * 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时， * 这个接口类型只能被这个类或其子类所实现 */class Control {    private  state:any;}interface  SelecttableControl extends Control {    select():void;}class Button extends Control {    select() {        console.log('button')    }}class TextBox extends Control {    select() {        console.log('TextBox')    }}class Tab extends Control {}class Box {    select() {    }}var textbox = new TextBox();var button = new Button();var tab = new Tab();textbox.select();//TextBoxbutton.select();//button//tab.select();//Error: Property 'select' does not exist on type 'Tab'.//通过接口调用var v:SelecttableControl = new TextBox();v.select();//TextBox/** * 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 * 因为state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 * 因为只有Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。 * 在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 * 实际上，SelectableControl就像Control一样，并拥有一个select方法。 * Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法）， * 但Image和Location类并不是这样的。 */